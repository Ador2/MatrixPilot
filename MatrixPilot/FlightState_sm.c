/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : FlightState.sm
 */


/* FlightState.sm

  Build FlightState_sm.c & .h from this file in the MatrixPilot module source directory with:
 
  >java -jar ../Tools/Smc.jar -c -verbose FlightState.sm
 
*/
#include "defines.h"
#include "mode_switch.h"
#include "flightplan.h"
#include "states.h"

extern int YellowTimer;
extern int NSGreenTimer;
extern int EWGreenTimer;


#include "FlightState.h"
#include "FlightState_sm.h"

#define getOwner(fsm) (fsm)->_owner



static void FlightStateState_go_Acquiring(struct FlightStateContext *const fsm)
{
    getState(fsm)->Default(fsm);
}

static void FlightStateState_go_Calibrate(struct FlightStateContext *const fsm)
{
    getState(fsm)->Default(fsm);
}

static void FlightStateState_go_Manual(struct FlightStateContext *const fsm)
{
    getState(fsm)->Default(fsm);
}

static void FlightStateState_go_Return(struct FlightStateContext *const fsm)
{
    getState(fsm)->Default(fsm);
}

static void FlightStateState_go_Stabilised(struct FlightStateContext *const fsm)
{
    getState(fsm)->Default(fsm);
}

static void FlightStateState_go_Waypoint(struct FlightStateContext *const fsm)
{
    getState(fsm)->Default(fsm);
}

static void FlightStateState_Default(struct FlightStateContext *const fsm)
{
    if (getDebugFlag(fsm) != 0) {
        TRACE("TRANSITION   : %s.%s\n", getName(getState(fsm)), getTransition(fsm));
    }
    State_Default(fsm);
}

#define FlightStateMap_Manual_go_Acquiring FlightStateState_go_Acquiring
#define FlightStateMap_Manual_go_Calibrate FlightStateState_go_Calibrate
#define FlightStateMap_Manual_go_Manual FlightStateState_go_Manual
#define FlightStateMap_Manual_go_Return FlightStateState_go_Return
#define FlightStateMap_Manual_go_Stabilised FlightStateState_go_Stabilised
#define FlightStateMap_Manual_go_Waypoint FlightStateState_go_Waypoint
#define FlightStateMap_Manual_Default FlightStateState_Default
#define FlightStateMap_Stabilised_go_Acquiring FlightStateState_go_Acquiring
#define FlightStateMap_Stabilised_go_Calibrate FlightStateState_go_Calibrate
#define FlightStateMap_Stabilised_go_Manual FlightStateState_go_Manual
#define FlightStateMap_Stabilised_go_Return FlightStateState_go_Return
#define FlightStateMap_Stabilised_go_Stabilised FlightStateState_go_Stabilised
#define FlightStateMap_Stabilised_go_Waypoint FlightStateState_go_Waypoint
#define FlightStateMap_Stabilised_Default FlightStateState_Default
#define FlightStateMap_Waypoint_go_Acquiring FlightStateState_go_Acquiring
#define FlightStateMap_Waypoint_go_Calibrate FlightStateState_go_Calibrate
#define FlightStateMap_Waypoint_go_Manual FlightStateState_go_Manual
#define FlightStateMap_Waypoint_go_Return FlightStateState_go_Return
#define FlightStateMap_Waypoint_go_Stabilised FlightStateState_go_Stabilised
#define FlightStateMap_Waypoint_go_Waypoint FlightStateState_go_Waypoint
#define FlightStateMap_Waypoint_Default FlightStateState_Default
#define FlightStateMap_Return_go_Acquiring FlightStateState_go_Acquiring
#define FlightStateMap_Return_go_Calibrate FlightStateState_go_Calibrate
#define FlightStateMap_Return_go_Manual FlightStateState_go_Manual
#define FlightStateMap_Return_go_Return FlightStateState_go_Return
#define FlightStateMap_Return_go_Stabilised FlightStateState_go_Stabilised
#define FlightStateMap_Return_go_Waypoint FlightStateState_go_Waypoint
#define FlightStateMap_Return_Default FlightStateState_Default
#define FlightStateMap_DefaultState_go_Acquiring FlightStateState_go_Acquiring
#define FlightStateMap_DefaultState_go_Calibrate FlightStateState_go_Calibrate
#define FlightStateMap_DefaultState_go_Manual FlightStateState_go_Manual
#define FlightStateMap_DefaultState_go_Return FlightStateState_go_Return
#define FlightStateMap_DefaultState_go_Stabilised FlightStateState_go_Stabilised
#define FlightStateMap_DefaultState_go_Waypoint FlightStateState_go_Waypoint

#undef FlightStateMap_Manual_go_Return
static void FlightStateMap_Manual_go_Return(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : FlightStateMap_Manual)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: FlightStateMap_&FlightStateMap_Manual.go_Return()\n");
    }
    clearState(fsm);
    FlightState_ent_Return(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : FlightStateMap_&FlightStateMap_Manual.go_Return()\n");
    }
    setState(fsm, &FlightStateMap_Return);
}

#undef FlightStateMap_Manual_go_Stabilised
static void FlightStateMap_Manual_go_Stabilised(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : FlightStateMap_Manual)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: FlightStateMap_&FlightStateMap_Manual.go_Stabilised()\n");
    }
    clearState(fsm);
    FlightState_ent_Stabilised(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : FlightStateMap_&FlightStateMap_Manual.go_Stabilised()\n");
    }
    setState(fsm, &FlightStateMap_Stabilised);
}

const struct FlightStateState FlightStateMap_Manual = {
    FlightStateMap_Manual_go_Acquiring,
    FlightStateMap_Manual_go_Calibrate,
    FlightStateMap_Manual_go_Manual,
    FlightStateMap_Manual_go_Return,
    FlightStateMap_Manual_go_Stabilised,
    FlightStateMap_Manual_go_Waypoint,
    FlightStateMap_Manual_Default,
    0, "FlightStateMap_Manual"
};

#undef FlightStateMap_Stabilised_go_Manual
static void FlightStateMap_Stabilised_go_Manual(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : FlightStateMap_Stabilised)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: FlightStateMap_&FlightStateMap_Stabilised.go_Manual()\n");
    }
    clearState(fsm);
    FlightState_ent_Manual(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : FlightStateMap_&FlightStateMap_Stabilised.go_Manual()\n");
    }
    setState(fsm, &FlightStateMap_Manual);
}

#undef FlightStateMap_Stabilised_go_Return
static void FlightStateMap_Stabilised_go_Return(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : FlightStateMap_Stabilised)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: FlightStateMap_&FlightStateMap_Stabilised.go_Return()\n");
    }
    clearState(fsm);
    FlightState_ent_Return(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : FlightStateMap_&FlightStateMap_Stabilised.go_Return()\n");
    }
    setState(fsm, &FlightStateMap_Return);
}

#undef FlightStateMap_Stabilised_go_Waypoint
static void FlightStateMap_Stabilised_go_Waypoint(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : FlightStateMap_Stabilised)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: FlightStateMap_&FlightStateMap_Stabilised.go_Waypoint()\n");
    }
    clearState(fsm);
    FlightState_ent_Waypoint(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : FlightStateMap_&FlightStateMap_Stabilised.go_Waypoint()\n");
    }
    setState(fsm, &FlightStateMap_Waypoint);
}

const struct FlightStateState FlightStateMap_Stabilised = {
    FlightStateMap_Stabilised_go_Acquiring,
    FlightStateMap_Stabilised_go_Calibrate,
    FlightStateMap_Stabilised_go_Manual,
    FlightStateMap_Stabilised_go_Return,
    FlightStateMap_Stabilised_go_Stabilised,
    FlightStateMap_Stabilised_go_Waypoint,
    FlightStateMap_Stabilised_Default,
    1, "FlightStateMap_Stabilised"
};

#undef FlightStateMap_Waypoint_go_Return
static void FlightStateMap_Waypoint_go_Return(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : FlightStateMap_Waypoint)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: FlightStateMap_&FlightStateMap_Waypoint.go_Return()\n");
    }
    clearState(fsm);
    FlightState_ent_Return(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : FlightStateMap_&FlightStateMap_Waypoint.go_Return()\n");
    }
    setState(fsm, &FlightStateMap_Return);
}

#undef FlightStateMap_Waypoint_go_Stabilised
static void FlightStateMap_Waypoint_go_Stabilised(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : FlightStateMap_Waypoint)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: FlightStateMap_&FlightStateMap_Waypoint.go_Stabilised()\n");
    }
    clearState(fsm);
    FlightState_ent_Stabilised(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : FlightStateMap_&FlightStateMap_Waypoint.go_Stabilised()\n");
    }
    setState(fsm, &FlightStateMap_Stabilised);
}

const struct FlightStateState FlightStateMap_Waypoint = {
    FlightStateMap_Waypoint_go_Acquiring,
    FlightStateMap_Waypoint_go_Calibrate,
    FlightStateMap_Waypoint_go_Manual,
    FlightStateMap_Waypoint_go_Return,
    FlightStateMap_Waypoint_go_Stabilised,
    FlightStateMap_Waypoint_go_Waypoint,
    FlightStateMap_Waypoint_Default,
    2, "FlightStateMap_Waypoint"
};

#undef FlightStateMap_Return_go_Stabilised
static void FlightStateMap_Return_go_Stabilised(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : FlightStateMap_Return)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: FlightStateMap_&FlightStateMap_Return.go_Stabilised()\n");
    }
    clearState(fsm);
    FlightState_ent_Stabilised(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : FlightStateMap_&FlightStateMap_Return.go_Stabilised()\n");
    }
    setState(fsm, &FlightStateMap_Stabilised);
}

#undef FlightStateMap_Return_go_Waypoint
static void FlightStateMap_Return_go_Waypoint(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : FlightStateMap_Return)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: FlightStateMap_&FlightStateMap_Return.go_Waypoint()\n");
    }
    clearState(fsm);
    FlightState_ent_Waypoint(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : FlightStateMap_&FlightStateMap_Return.go_Waypoint()\n");
    }
    setState(fsm, &FlightStateMap_Waypoint);
}

const struct FlightStateState FlightStateMap_Return = {
    FlightStateMap_Return_go_Acquiring,
    FlightStateMap_Return_go_Calibrate,
    FlightStateMap_Return_go_Manual,
    FlightStateMap_Return_go_Return,
    FlightStateMap_Return_go_Stabilised,
    FlightStateMap_Return_go_Waypoint,
    FlightStateMap_Return_Default,
    3, "FlightStateMap_Return"
};

#define StartupMap_Start_go_Acquiring FlightStateState_go_Acquiring
#define StartupMap_Start_go_Calibrate FlightStateState_go_Calibrate
#define StartupMap_Start_go_Manual FlightStateState_go_Manual
#define StartupMap_Start_go_Return FlightStateState_go_Return
#define StartupMap_Start_go_Stabilised FlightStateState_go_Stabilised
#define StartupMap_Start_go_Waypoint FlightStateState_go_Waypoint
#define StartupMap_Start_Default FlightStateState_Default
#define StartupMap_Calibrate_go_Acquiring FlightStateState_go_Acquiring
#define StartupMap_Calibrate_go_Calibrate FlightStateState_go_Calibrate
#define StartupMap_Calibrate_go_Manual FlightStateState_go_Manual
#define StartupMap_Calibrate_go_Return FlightStateState_go_Return
#define StartupMap_Calibrate_go_Stabilised FlightStateState_go_Stabilised
#define StartupMap_Calibrate_go_Waypoint FlightStateState_go_Waypoint
#define StartupMap_Calibrate_Default FlightStateState_Default
#define StartupMap_Acquiring_go_Acquiring FlightStateState_go_Acquiring
#define StartupMap_Acquiring_go_Calibrate FlightStateState_go_Calibrate
#define StartupMap_Acquiring_go_Manual FlightStateState_go_Manual
#define StartupMap_Acquiring_go_Return FlightStateState_go_Return
#define StartupMap_Acquiring_go_Stabilised FlightStateState_go_Stabilised
#define StartupMap_Acquiring_go_Waypoint FlightStateState_go_Waypoint
#define StartupMap_Acquiring_Default FlightStateState_Default
#define StartupMap_DefaultState_go_Acquiring FlightStateState_go_Acquiring
#define StartupMap_DefaultState_go_Calibrate FlightStateState_go_Calibrate
#define StartupMap_DefaultState_go_Manual FlightStateState_go_Manual
#define StartupMap_DefaultState_go_Return FlightStateState_go_Return
#define StartupMap_DefaultState_go_Stabilised FlightStateState_go_Stabilised
#define StartupMap_DefaultState_go_Waypoint FlightStateState_go_Waypoint

#undef StartupMap_Start_go_Calibrate
static void StartupMap_Start_go_Calibrate(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : StartupMap_Start)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: StartupMap_&StartupMap_Start.go_Calibrate()\n");
    }
    clearState(fsm);
    FlightState_ent_Calibrate(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : StartupMap_&StartupMap_Start.go_Calibrate()\n");
    }
    setState(fsm, &StartupMap_Calibrate);
}

const struct FlightStateState StartupMap_Start = {
    StartupMap_Start_go_Acquiring,
    StartupMap_Start_go_Calibrate,
    StartupMap_Start_go_Manual,
    StartupMap_Start_go_Return,
    StartupMap_Start_go_Stabilised,
    StartupMap_Start_go_Waypoint,
    StartupMap_Start_Default,
    4, "StartupMap_Start"
};

#undef StartupMap_Calibrate_go_Acquiring
static void StartupMap_Calibrate_go_Acquiring(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : StartupMap_Calibrate)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: StartupMap_&StartupMap_Calibrate.go_Acquiring()\n");
    }
    clearState(fsm);
    FlightState_ent_Acquiring(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : StartupMap_&StartupMap_Calibrate.go_Acquiring()\n");
    }
    setState(fsm, &StartupMap_Acquiring);
}

const struct FlightStateState StartupMap_Calibrate = {
    StartupMap_Calibrate_go_Acquiring,
    StartupMap_Calibrate_go_Calibrate,
    StartupMap_Calibrate_go_Manual,
    StartupMap_Calibrate_go_Return,
    StartupMap_Calibrate_go_Stabilised,
    StartupMap_Calibrate_go_Waypoint,
    StartupMap_Calibrate_Default,
    5, "StartupMap_Calibrate"
};

#undef StartupMap_Acquiring_go_Manual
static void StartupMap_Acquiring_go_Manual(struct FlightStateContext *const fsm)
{
    struct FlightState *ctxt = getOwner(fsm);

    if (getDebugFlag(fsm) != 0) {
        TRACE("LEAVING STATE   : StartupMap_Acquiring)\n");
    }
    if (getDebugFlag(fsm) != 0) {
        TRACE("ENTER TRANSITION: StartupMap_&StartupMap_Acquiring.go_Manual()\n");
    }
    clearState(fsm);
    FlightState_ent_Manual(ctxt);
    if (getDebugFlag(fsm) != 0) {
        TRACE("EXIT TRANSITION : StartupMap_&StartupMap_Acquiring.go_Manual()\n");
    }
    setState(fsm, &StartupMap_Start);
}

const struct FlightStateState StartupMap_Acquiring = {
    StartupMap_Acquiring_go_Acquiring,
    StartupMap_Acquiring_go_Calibrate,
    StartupMap_Acquiring_go_Manual,
    StartupMap_Acquiring_go_Return,
    StartupMap_Acquiring_go_Stabilised,
    StartupMap_Acquiring_go_Waypoint,
    StartupMap_Acquiring_Default,
    6, "StartupMap_Acquiring"
};

#ifdef NO_FLIGHTSTATE_SM_MACRO
void FlightStateContext_Init(struct FlightStateContext *const fsm, struct FlightState *const owner)
{
    FSM_INIT(fsm, &FlightStateMap_Manual);
    fsm->_owner = owner;
}

void FlightStateContext_go_Acquiring(struct FlightStateContext *const fsm)
{
    const struct FlightStateState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "go_Acquiring");
    state->go_Acquiring(fsm);
    setTransition(fsm, NULL);
}

void FlightStateContext_go_Calibrate(struct FlightStateContext *const fsm)
{
    const struct FlightStateState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "go_Calibrate");
    state->go_Calibrate(fsm);
    setTransition(fsm, NULL);
}

void FlightStateContext_go_Manual(struct FlightStateContext *const fsm)
{
    const struct FlightStateState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "go_Manual");
    state->go_Manual(fsm);
    setTransition(fsm, NULL);
}

void FlightStateContext_go_Return(struct FlightStateContext *const fsm)
{
    const struct FlightStateState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "go_Return");
    state->go_Return(fsm);
    setTransition(fsm, NULL);
}

void FlightStateContext_go_Stabilised(struct FlightStateContext *const fsm)
{
    const struct FlightStateState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "go_Stabilised");
    state->go_Stabilised(fsm);
    setTransition(fsm, NULL);
}

void FlightStateContext_go_Waypoint(struct FlightStateContext *const fsm)
{
    const struct FlightStateState* state = getState(fsm);

    assert(state != NULL);
    setTransition(fsm, "go_Waypoint");
    state->go_Waypoint(fsm);
    setTransition(fsm, NULL);
}
#endif

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
